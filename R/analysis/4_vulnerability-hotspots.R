################################################################################
# @Manuscript - "Hotspots of social and ecological impacts from freshwater stress and storage loss" (Huggins et al.) 
# @Description - Perform vulnerability analysis and identify hotspots. Plot scatterplots and maps.
################################################################################

# Load 'here' library for easy path management.  
library(here)

# Import all setup and user-defined functions in R/setup and R/udfs folders
invisible(sapply(paste0(here("R/setup"), "/", list.files(here("R/setup"))), source)) 
invisible(sapply(paste0(here("R/udfs"), "/", list.files(here("R/udfs"))), source))

# Import data ----
cind <- raster(here('Data/fwss_ind_comb.tif'))
ac15 <- raster(here::here("Data", "AdaptiveCap2015.tif"))
efn <- raster(here("Data/Dimensions/EFN_0d5.tif"))
vsi <- raster(here("Data/Dimensions/VSI_aetw_0d5.tif"))
dis  <- raster(here('Data/HyBas4_cleaned.tif'))

# Import social-ecological dimension data
pop <- raster(here("Data/Dimensions/gpw_v4_population_count_adjusted_to_2015_unwpp_country_totals_rev11_2015_30_min.tif"))
cal <- raster(here("Data/Dimensions/kcal_0d5.tif"))
gdp <- raster(here("Data/Dimensions/GDP_2015_0d5.tif"))
amphsr <- raster(here('Data/all_amph_0d5.tif'))
ramsar <- raster(here('Data/ramsar_count.tif'))
wcc <- raster('C:/Users/xande/Desktop/Scripts/SimilarityIndex/Data/Archive/cleaned/WCC_L20_count.tif')

# Clean amphibian species richness and Water Conflict Chronology data
amphsr[amphsr < 0 | amphsr > 129] <- 0
wcc[is.na(wcc)] <- 0

# Derive ecological sensitivity indicator ----

# Establish constant discretization extent for masking 
dis.ext <- dis
dis.ext[dis.ext >= 0] <- 1

# Convert both inputs into area-weighted percentiles, based on contributing area

# Environmental flow sensitivity to groundwater head decline
ef.ptl <- RasterAreaPercentiles(RasterToClassify = efn,
                                WeightRaster = WGS84_areaRaster(0.5),
                                MaskRaster = dis.ext,
                                clipToExtent = "clip",
                                CRS.set = crs(dis.ext),
                                ext.set = extent(dis.ext))
ef.ptl[ef.ptl > 0] <- (1 - ef.ptl[ef.ptl > 0]) + 0.01 # Invert as greater depths are less sensitive

# Vegetation productivity sensitivity to soil moisture & shallow groundwater anomalies
vsi[is.na(vsi) | dis.ext != 1] <- NA
vsi.ptl <- RasterAreaPercentiles(RasterToClassify = vsi,
                                 WeightRaster = WGS84_areaRaster(0.5),
                                 MaskRaster = dis.ext,
                                 clipToExtent = "clip",
                                 CRS.set = crs(dis.ext),
                                 ext.set = extent(dis.ext))

# Invert social adaptive capacity ----
ac <- 1 - ac15

# Calculate ecological sensitivity, inverted adaptive capacity, and stress indicator per basin ---- 
c_df <- raster::stack(dis, cind, ef.ptl, vsi.ptl, ac, pop, cal, gdp, amphsr, 
                      ramsar, wcc, WGS84_areaRaster(0.5)) %>% 
  as.data.frame() %>% 
  set_colnames(c('dis', 'cind', 'efn',  'vsi', 'ac', 'pop', 'cal', 'gdp', 'sr', 
                 'ramsar', 'wcc', 'area'))
c_df <- c_df[complete.cases(c_df$dis),]

# Remove basins that do not have adaptive capacity data 
disclude <- c(1130, 1520, 1840, 2170, 2360, 2450, 2530, 3550, 4240,
              4370, 5320, 5330, 5370, 5430, 5520, 5530, 5540, 5740,
              6540, 6730, 7220, 7610, 7630, 7650, 7710, 7740)

for (i in 1:length(disclude)) {
  c_df <- c_df %>% filter(dis != disclude[i])
}

c_df <- c_df %>% 
  group_by(dis) %>% 
  summarise(
    cind = getmode(cind), # only need to calculate mode as already summarized at basin scale (any summary statistic will do...)
    efn = weighted.mean(x = efn, w = area, na.rm = T),
    vsi = weighted.mean(x = vsi, w = area, na.rm = T),
    ac = weighted.mean(x = ac, w = area, na.rm = T),
    pop = sum(pop, na.rm  = T),
    cal = sum(cal, na.rm = T),
    gdp = sum(gdp, na.rm = T),
    sr = weighted.mean(sr, area, na.rm = T),
    ramsar = sum(ramsar, na.rm = T),
    wcc = sum(wcc, na.rm = T)
  )

# Ecological sensitivity is mean of vegetation and environmental flow inputs, normalized by the maximum basin value of this average
c_df$ecosens <- (c_df$vsi + c_df$efn)/2
c_df$ecosens <- c_df$ecosens/max(c_df$ecosens, na.rm = T)

# Identify ecological vulnerability hotspots ----

# Ecological vulnerability is product of combined stress indicator and ecological sensitivity
c_df$ecoprod <- c_df$cind * c_df$ecosens

# Identify hotspots through Head/Tail breaks method
htb_e <- ht_breaks2.0(x = c_df$ecoprod, tsh = 0.8)


# Identify social vulnerability hotspots ----

# Social vulnerability is product of combined stress indicator and inverted adaptive capacity
c_df$acprod <- c_df$cind * c_df$ac

# Identify hotspots through Head/Tail breaks method
htb_a <- ht_breaks2.0(x = c_df$acprod, tsh = 0.8)


# Identify social-ecological vulnerability hotspots ----
cor.test(x = c_df$ac, y = c_df$ecosens, method = "spearman")

cor.test(x = c_df$acprod, y = c_df$ecoprod, method = "spearman")


# Social-ecological sensitivity is fuzzy sum of ecological sensitivity and inv. adaptive capacity
c_df$overallsens <- 1 - (1-c_df$ecosens)*(1-c_df$ac) # this is fuzzy sum

# Social-ecological vulnerability is product of combined stress indicator and social-ecological sensitivity
c_df$overallprod <- c_df$cind * c_df$overallsens

# Identify hotspots through Head/Tail breaks method
htb_o <- ht_breaks2.0(x = c_df$overallprod, tsh = 0.8)


# Evaluate relationship between ecological sensitivity and inverted adaptive capacity ----



# Plot hotspot classification scatterplots ----

# 1 - Ecological hotspots
# Create flag to identify hotspots
c_df$ecohot <- rep(NA, nrow(c_df))

for (i in 1:nrow(c_df)) {
  c_df$ecohot[i] <- ifelse(c_df$ecoprod[i] >= htb_e[2], 2, 1)
}

# Generate points along curves for vulnerability class thresholds
invlin <- data.frame(x = seq(htb_e[1], 1, length.out = 300), 
                     y1 = rep(NA, 1000),
                     y2 = rep(NA, 1000),
                     y3 = rep(NA, 1000))
for (i in 1:1000) { 
  invlin$y1[i] <- min(htb_e[1]/invlin$x[i], 1)
  invlin$y2[i] <- min(htb_e[2]/invlin$x[i], 1)
  invlin$y3[i] <- min(htb_e[3]/invlin$x[i], 1)
}

tsh_ln <- invlin[invlin[,1] >= htb_e[2]-0.005,]

aa = 0.4 # Transparency 
mp <- ggplot() +
  geom_ribbon(data = invlin, aes(x = x, ymin = y1, ymax = y2), fill = "#B99232", alpha = aa) +
  geom_ribbon(data = invlin, aes(x = x, ymin = y2, ymax = y3), fill = "#9D5819", alpha = aa) +
  geom_ribbon(data = invlin, aes(x = x, ymin = y3, ymax = 1),  fill = "#7E1900", alpha = aa) +
  geom_point(data = subset(c_df, ecohot == 1), aes(x = cind, y = ecosens), 
             alpha= 0.2, shape = 21, color = 'black', stroke = 2) +
  geom_point(data = subset(c_df, ecohot == 2), aes(x = cind, y = ecosens), 
             alpha= 1, shape = 19, color = 'black', size = 4) +
  geom_line(data = invlin, aes(x = x, y = y1), col = 'black', lwd = 0.5, linetype = "dashed") +
  geom_line(data = tsh_ln, aes(x = x, y = y2), col = 'black', lwd = 1.5) +
  geom_line(data = invlin, aes(x = x, y = y3), col = 'black', lwd = 0.5, linetype = "dashed") +
  scale_size(range = c(.1, 24)) +
  coord_cartesian(xlim = c(0, 1.05), ylim = c(0, 1.05), expand = c(0, 0), clip = "off") +
  scale_y_continuous(breaks = seq(0, 1, 0.2), 
                     limits = c(0, 1)) + 
  theme1 + theme(axis.ticks.x = element_line(size = 1))  
mp
ggsave(plot = last_plot(), 
       paste0("C:/Users/xande/Desktop/jt_prep/4_ecosens.pdf", sep = ""),
       dpi = 500, width = 6, height = 4, units = "in")


# 2 - Social hotspots
# Create flag to identify hotspots
c_df$achot <- rep(NA, nrow(c_df))

for (i in 1:nrow(c_df)) {
  c_df$achot[i] <- ifelse(c_df$acprod[i] >= htb_a[2], 2, 1)
}

# Generate points along curves for vulnerability class thresholds
invlin <- data.frame(x = seq(htb_a[1], 1, length.out = 1000), 
                     y1 = rep(NA, 1000),
                     y2 = rep(NA, 1000),
                     y3 = rep(NA, 1000))
for (i in 1:1000) { 
  invlin$y1[i] <- min(htb_a[1]/invlin$x[i], 1)
  invlin$y2[i] <- min(htb_a[2]/invlin$x[i], 1)
  invlin$y3[i] <- min(htb_a[3]/invlin$x[i], 1)
}

tsh_ln <- invlin[invlin[,1] >= htb_a[2]-0.005,]

aa = 0.4
mp <- ggplot() +
  geom_ribbon(data = invlin, aes(x = x, ymin = y1, ymax = y2), fill = "#B99232", alpha = aa) +
  geom_ribbon(data = invlin, aes(x = x, ymin = y2, ymax = y3), fill = "#9D5819", alpha = aa) +
  geom_ribbon(data = invlin, aes(x = x, ymin = y3, ymax = 1),  fill = "#7E1900", alpha = aa) +
  geom_point(data = subset(c_df, achot == 1), aes(x = cind, y = ac), 
             alpha= 0.2, shape = 21, color = 'black', stroke = 2) +
  geom_point(data = subset(c_df, achot == 2), aes(x = cind, y = ac), 
             alpha= 1, shape = 19, color = 'black', size = 4) +
  geom_line(data = invlin, aes(x = x, y = y1), col = 'black', lwd = 0.5, linetype = "dashed") +
  geom_line(data = tsh_ln, aes(x = x, y = y2), col = 'black', lwd = 1.5) +
  geom_line(data = invlin, aes(x = x, y = y3), col = 'black', lwd = 0.5, linetype = "dashed") +
  scale_size(range = c(.1, 24)) +
  coord_cartesian(xlim = c(0, 1.05), ylim = c(0, 1.05), expand = c(0, 0), clip = "off") +
  scale_y_continuous(breaks = seq(0, 1, 0.2), 
                     limits = c(0, 1)) + 
  theme1 + theme(axis.ticks.x = element_line(size = 1))  
mp
ggsave(plot = last_plot(), 
       paste0("C:/Users/xande/Desktop/jt_prep/4_acsens.pdf", sep = ""),
       dpi = 500, width = 6, height = 4, units = "in")


# 3 - Social-ecological hotspots
# Create flag to identify hotspots
c_df$ovhot <- rep(NA, nrow(c_df))

for (i in 1:nrow(c_df)) {
  c_df$ovhot[i] <- ifelse(c_df$overallprod[i] >= htb_o[2], 2, 1)
}

# Generate points along curves for vulnerability class thresholds
invlin <- data.frame(x = seq(htb_o[1], 1, length.out = 1000), 
                     y1 = rep(NA, 1000),
                     y2 = rep(NA, 1000),
                     y3 = rep(NA, 1000))
for (i in 1:1000) { 
  invlin$y1[i] <- min(htb_o[1]/invlin$x[i], 1)
  invlin$y2[i] <- min(htb_o[2]/invlin$x[i], 1)
  invlin$y3[i] <- min(htb_o[3]/invlin$x[i], 1)
}

tsh_ln <- invlin[invlin[,1] >= htb_o[2]-0.005,]

aa = 0.4
mp <- ggplot() +
  geom_ribbon(data = invlin, aes(x = x, ymin = y1, ymax = y2), fill = "#B99232", alpha = aa) +
  geom_ribbon(data = invlin, aes(x = x, ymin = y2, ymax = y3), fill = "#9D5819", alpha = aa) +
  geom_ribbon(data = invlin, aes(x = x, ymin = y3, ymax = 1),  fill = "#7E1900", alpha = aa) +
  geom_point(data = subset(c_df, ovhot == 1), aes(x = cind, y = overallsens), 
             alpha= 0.2, shape = 21, color = 'black', stroke = 2) +
  geom_point(data = subset(c_df, ovhot == 2), aes(x = cind, y = overallsens), 
             alpha= 1, shape = 19, color = 'black', size = 4) +
  geom_line(data = invlin, aes(x = x, y = y1), col = 'black', lwd = 0.5, linetype = "dashed") +
  geom_line(data = tsh_ln, aes(x = x, y = y2), col = 'black', lwd = 1.5) +
  geom_line(data = invlin, aes(x = x, y = y3), col = 'black', lwd = 0.5, linetype = "dashed") +
  scale_size(range = c(.1, 24)) +
  coord_cartesian(xlim = c(0, 1.05), ylim = c(0, 1.05), expand = c(0, 0), clip = "off") +
  scale_y_continuous(breaks = seq(0, 1, 0.2), 
                     limits = c(0, 1)) + 
  theme1 + theme(axis.ticks.x = element_line(size = 1)) 
mp
ggsave(plot = last_plot(), 
       paste0("C:/Users/xande/Desktop/jt_prep/4_overallsens.pdf", sep = ""),
       dpi = 500, width = 6, height = 4, units = "in")


# Calculate dimension sums for vulnerability class summaries ----

# Population
ModerateVul(c_df, 'pop', 1e9)
HighVul(c_df, 'pop', 1e9)
VeryHighVul(c_df, 'pop', 1e9)

# Crop calories
ModerateVul(c_df, 'cal', 1e15)
HighVul(c_df, 'cal', 1e15)
VeryHighVul(c_df, 'cal', 1e15)

# GDP
ModerateVul(c_df, 'gdp', 1e12)
HighVul(c_df, 'gdp', 1e12)
VeryHighVul(c_df, 'gdp', 1e12)

# Ramsar wetlands
ModerateVul(c_df, 'ramsar', 1)
HighVul(c_df, 'ramsar', 1)
VeryHighVul(c_df, 'ramsar', 1)

# World conflict chronology
ModerateVul(c_df, 'wcc', 1)
HighVul(c_df, 'wcc', 1)
VeryHighVul(c_df, 'wcc', 1)

# Amphibian species richness
c_df %>% filter(overallprod >= htb_o[1] & overallprod < htb_o[2]) %>% 
  pull(sr) %>% mean(na.rm = T) %>% round(2)

c_df %>% filter(overallprod >= htb_o[2] & overallprod < htb_o[3]) %>% 
  pull(sr) %>% mean(na.rm = T) %>% round(2)

c_df %>% filter(overallprod >= htb_o[3]) %>% 
  pull(sr) %>% mean(na.rm = T) %>% round(2)

# Totals across both hotspot vulnerability classes
c_df %>% filter(ovhot == 2) %>% pull(pop) %>% sum(na.rm = T)/1e9
c_df %>% filter(ovhot == 2) %>% pull(cal) %>% sum(na.rm = T)/1e15
c_df %>% filter(ovhot == 2) %>% pull(gdp) %>% sum(na.rm = T)/1e12

# Calculate number of social-ecological hotspot basins
c_df %>% filter(overallprod >= htb_o[1] & overallprod < htb_o[2]) %>% nrow()
c_df %>% filter(overallprod >= htb_o[2] & overallprod < htb_o[3]) %>% nrow()
c_df %>% filter(overallprod >= htb_o[3]) %>% nrow()
c_df %>% filter(overallprod >= htb_o[2]) %>% nrow()

# Calculate number of ecological hotspot basins
c_df %>% filter(ecoprod >= htb_e[1] & ecoprod < htb_e[2]) %>% nrow()
c_df %>% filter(ecoprod >= htb_e[2] & ecoprod < htb_e[3]) %>% nrow()
c_df %>% filter(ecoprod >= htb_e[3]) %>% nrow()

# Calculate number of social hotspot basins
c_df %>% filter(acprod >= htb_a[1] & acprod < htb_a[2]) %>% nrow()
c_df %>% filter(acprod >= htb_a[2] & acprod < htb_a[3]) %>% nrow()
c_df %>% filter(acprod >= htb_a[3]) %>% nrow()

# Reprodue results spatially for mapping ----

# Calculate inverted adaptive capacity per basin
ac.f <- FeatureAreaAverage(FT.id = dis, 
                           RawDS = 1 - ac15,
                           AreaDS = WGS84_areaRaster(0.5), 
                           operation = 'mean',
                           varnam = 'ac')

# Calculate ecological sensitivity per basin
es.f <- FeatureAreaAverage(FT.id = dis, 
                           RawDS = (ef.ptl+vsi.ptl)/2,
                           AreaDS = WGS84_areaRaster(0.5), 
                           operation = 'mean',
                           varnam = 'ecosens')

# Normalize by maximum basin value
es.f <- es.f/max(es.f[], na.rm = T)

# Calculate social-ecological sensitivity through fuzzy sum of inputs
ov.f <- 1 - (1 - ac.f)*(1-es.f) 

# Identify hotspots through reclassification based on Head/Tail breaks results
# 1 - Social hotspots
rclmat <- c(0, htb_a[1],        0, 
            htb_a[1], htb_a[2], 1,
            htb_a[2], htb_a[3], 2,
            htb_a[3], 1,        3) %>% 
  matrix(ncol = 3, byrow = T)
achot <- reclassify(ac.f*cind, rclmat, include.lowest = T) # Note that we're reclassifying the product of inverted adaptive capacity and the combined freshwater stress indicator (thus social vulnerability)

# 2 - Ecological hotspots
rclmat <- c(0, htb_e[1],        0, 
            htb_e[1], htb_e[2], 1,
            htb_e[2], htb_e[3], 2,
            htb_e[3], 1,        3) %>% 
  matrix(ncol = 3, byrow = T)
eshot <- reclassify(es.f*cind, rclmat, include.lowest = T)  # Note that we're reclassifying the product of ecological sensitivity and the combined freshwater stress indicator (thus ecological vulnerability)

# 3 - Social-ecological hotspots
rclmat <- c(0, htb_o[1],        0, 
            htb_o[1], htb_o[2], 1,
            htb_o[2], htb_o[3], 2,
            htb_o[3], 1,        3) %>% 
  matrix(ncol = 3, byrow = T)
ovhot <- reclassify(ov.f*cind, rclmat, include.lowest = T) # Note that we're reclassifying the product of social-ecological sensitivity and the combined freshwater stress indicator (thus social-ecological vulnerability)

# Write raster of the overall hotspot results for future use
writeRaster(ovhot, here('Data/overallhotspotclasses.tif'),
            format = 'GTiff', overwrite = T)

# Plot all three hotspot maps ----

# Import vector boundary files
disborders <- sf::read_sf(here('Data/hybas_l4_0d5.shp'))
coastlines <- sf::read_sf(here('Data/hybas_l4_coastlines.shp'))

# Stack the rasters to loop through plotting function
plotstack <- stack(achot, eshot, ovhot)

for (i in 1:nlayers(plotstack)) {
  
  plt.obj <- tmap_clipproj(plotstack[[i]])
  
  cus.pal <- c("grey80", "#B99232", "#9D5819", "#7E1900")
  
  emph <- raster(plotstack[[i]])
  for (j in c(2, 3)) {emph[plotstack[[i]] == j] <- 1}
  
  emph <- raster::rasterToPolygons(emph, na.rm = T, dissolve = T)
  
  
  tm <- tm_shape(plt.obj, projection = "+proj=robin") +
    tm_raster(style = "cat", palette = cus.pal) +
    tm_shape(disborders) +
    tm_borders(lwd = 0.1, col = "grey40") +
    tm_shape(coastlines) +
    tm_borders(lwd = 0.7, col = "black") +
    tm_shape(emph) +
    tm_borders(lwd = 2, col = "black") +
    tm_layout(legend.show = F, earth.boundary = c(-179, -60, 179, 88),
              earth.boundary.color = "white", space.color = "white",
              legend.frame = F, frame = F,
              outer.margins = c(-0, -0.09, -0, -0.04)) # B, L, T, R
  tm
  assign(paste0("plt_", i, sep = ""), tm)
  
  tmap_save(tm, paste0("C:/Users/xande/Desktop/jt_prep/4_hotspots_", i, 
                       ".svg", sep = ""),
            units = "in")
}